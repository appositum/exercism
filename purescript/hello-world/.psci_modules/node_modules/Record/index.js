"use strict";
var Data_Eq = require("../Data.Eq/index.js");
var Data_Function_Uncurried = require("../Data.Function.Uncurried/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_Symbol = require("../Data.Symbol/index.js");
var Prelude = require("../Prelude/index.js");
var Record_Unsafe = require("../Record.Unsafe/index.js");
var Record_Unsafe_Union = require("../Record.Unsafe.Union/index.js");
var Type_Row = require("../Type.Row/index.js");
var Unsafe_Coerce = require("../Unsafe.Coerce/index.js");
var EqualFields = function (equalFields) {
    this.equalFields = equalFields;
};

// | Merges two records with the first record's labels taking precedence in the
// | case of overlaps. Unlike `merge`, this does not remove duplicate labels
// | from the resulting record type. This can result in better inference for
// | some pipelines, deferring the need for a `Nub` constraint.
// |
// | For example:
// |
// | ```purescript
// | union { x: 1, y: "y" } { y: 2, z: true }
// |  :: { x :: Int, y :: String, y :: Int, z :: Boolean }
// | ```
var union = function (dictUnion) {
    return function (l) {
        return function (r) {
            return Record_Unsafe_Union.unsafeUnionFn(l, r);
        };
    };
};

// | Set a property for a label which is specified using a value-level proxy for
// | a type-level string.
// |
// | For example:
// |
// | ```purescript
// | set (SProxy :: SProxy "x")
// |   :: forall r a b. a -> { x :: b | r } -> { x :: a | r }
// | ```
var set = function (dictIsSymbol) {
    return function (dictCons) {
        return function (dictCons1) {
            return function (l) {
                return function (b) {
                    return function (r) {
                        return Record_Unsafe.unsafeSet(Data_Symbol.reflectSymbol(dictIsSymbol)(l))(b)(r);
                    };
                };
            };
        };
    };
};

// | A coercion which removes duplicate labels from a record's type.
var nub = function (dictNub) {
    return Unsafe_Coerce.unsafeCoerce;
};

// | Merges two records with the first record's labels taking precedence in the
// | case of overlaps.
// |
// | For example:
// |
// | ```purescript
// | merge { x: 1, y: "y" } { y: 2, z: true }
// |  :: { x :: Int, y :: String, z :: Boolean }
// | ```
var merge = function (dictUnion) {
    return function (dictNub) {
        return function (l) {
            return function (r) {
                return Record_Unsafe_Union.unsafeUnionFn(l, r);
            };
        };
    };
};

// | Insert a new property for a label which is specified using a value-level proxy for
// | a type-level string.
// |
// | For example:
// |
// | ```purescript
// | insert (SProxy :: SProxy "x")
// |   :: forall r a. Lacks "x" r => a -> { | r } -> { x :: a | r }
// | ```
var insert = function (dictIsSymbol) {
    return function (dictLacks) {
        return function (dictCons) {
            return function (l) {
                return function (a) {
                    return function (r) {
                        return Record_Unsafe.unsafeSet(Data_Symbol.reflectSymbol(dictIsSymbol)(l))(a)(r);
                    };
                };
            };
        };
    };
};

// | Get a property for a label which is specified using a value-level proxy for
// | a type-level string.
// |
// | For example:
// |
// | ```purescript
// | get (SProxy :: SProxy "x") :: forall r a. { x :: a | r } -> a
// | ```
var get = function (dictIsSymbol) {
    return function (dictCons) {
        return function (l) {
            return function (r) {
                return Record_Unsafe.unsafeGet(Data_Symbol.reflectSymbol(dictIsSymbol)(l))(r);
            };
        };
    };
};

// | Modify a property for a label which is specified using a value-level proxy for
// | a type-level string.
// |
// | For example:
// |
// | ```purescript
// | modify (SProxy :: SProxy "x")
// |   :: forall r a b. (a -> b) -> { x :: a | r } -> { x :: b | r }
// | ```
var modify = function (dictIsSymbol) {
    return function (dictCons) {
        return function (dictCons1) {
            return function (l) {
                return function (f) {
                    return function (r) {
                        return set(dictIsSymbol)(dictCons)(dictCons1)(l)(f(get(dictIsSymbol)(dictCons)(l)(r)))(r);
                    };
                };
            };
        };
    };
};
var equalFieldsNil = new EqualFields(function (v) {
    return function (v1) {
        return function (v2) {
            return true;
        };
    };
});
var equalFields = function (dict) {
    return dict.equalFields;
};
var equalFieldsCons = function (dictIsSymbol) {
    return function (dictEq) {
        return function (dictCons) {
            return function (dictEqualFields) {
                return new EqualFields(function (v) {
                    return function (a) {
                        return function (b) {
                            var get$prime = get(dictIsSymbol)(dictCons)(Data_Symbol.SProxy.value);
                            var equalRest = equalFields(dictEqualFields)(Type_Row.RLProxy.value);
                            return Data_Eq.eq(dictEq)(get$prime(a))(get$prime(b)) && equalRest(a)(b);
                        };
                    };
                });
            };
        };
    };
};

// | Check two records of the same type for equality.
var equal = function (dictRowToList) {
    return function (dictEqualFields) {
        return function (a) {
            return function (b) {
                return equalFields(dictEqualFields)(Type_Row.RLProxy.value)(a)(b);
            };
        };
    };
};

// | Merges two records where no labels overlap. This restriction exhibits
// | better inference than `merge` when the resulting record type is known,
// | but one argument is not.
// |
// | For example, hole `?help` is inferred to have type `{ b :: Int }` here:
// |
// | ```purescript
// | disjoinUnion { a: 5 } ?help :: { a :: Int, b :: Int }
// | ```
var disjointUnion = function (dictUnion) {
    return function (dictNub) {
        return function (l) {
            return function (r) {
                return Record_Unsafe_Union.unsafeUnionFn(l, r);
            };
        };
    };
};

// | Delete a property for a label which is specified using a value-level proxy for
// | a type-level string.
// |
// | Note that the type of the resulting row must _lack_ the specified property.
// | Since duplicate labels are allowed, this is checked with a type class constraint.
// |
// | For example:
// |
// | ```purescript
// | delete (SProxy :: SProxy "x")
// |   :: forall r a. Lacks "x" r => { x :: a | r } -> { | r }
// | ```
var $$delete = function (dictIsSymbol) {
    return function (dictLacks) {
        return function (dictCons) {
            return function (l) {
                return function (r) {
                    return Record_Unsafe.unsafeDelete(Data_Symbol.reflectSymbol(dictIsSymbol)(l))(r);
                };
            };
        };
    };
};

// | Rename a property for a label which is specified using a value-level proxy for
// | a type-level string.
// |
// | Note that the type of the resulting row must _lack_ the specified property.
// | Since duplicate labels are allowed, this is checked with a type class constraint.
// |
// | For example:
// |
// | ```purescript
// | rename (SProxy :: SProxy "x") (SProxy :: SProxy "y")
// |   :: forall a r. Lacks "x" r => Lacks "y" r => { x :: a | r} -> { y :: a | r}
// | ```
var rename = function (dictIsSymbol) {
    return function (dictIsSymbol1) {
        return function (dictCons) {
            return function (dictLacks) {
                return function (dictCons1) {
                    return function (dictLacks1) {
                        return function (prev) {
                            return function (next) {
                                return function (record) {
                                    return insert(dictIsSymbol1)(dictLacks1)(dictCons1)(next)(get(dictIsSymbol)(dictCons)(prev)(record))($$delete(dictIsSymbol)(dictLacks)(dictCons)(prev)(record));
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
module.exports = {
    get: get,
    set: set,
    modify: modify,
    insert: insert,
    "delete": $$delete,
    rename: rename,
    equal: equal,
    merge: merge,
    union: union,
    disjointUnion: disjointUnion,
    nub: nub,
    EqualFields: EqualFields,
    equalFields: equalFields,
    equalFieldsCons: equalFieldsCons,
    equalFieldsNil: equalFieldsNil
};
