"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Semigroupoid = require("../Control.Semigroupoid/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Effect = require("../Effect/index.js");
var Effect_AVar = require("../Effect.AVar/index.js");
var Effect_Aff = require("../Effect.Aff/index.js");
var Effect_Class = require("../Effect.Class/index.js");
var Effect_Exception = require("../Effect.Exception/index.js");
var Prelude = require("../Prelude/index.js");

// | Attempts to synchronously take an AVar value, leaving it empty. If the
// | AVar is empty, this will return `Nothing`.
var tryTake = function ($6) {
    return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_AVar.tryTake($6));
};

// | Attempts to synchronously read an AVar. If the AVar is empty, this will
// | return `Nothing`.
var tryRead = function ($7) {
    return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_AVar.tryRead($7));
};

// | Attempts to synchronously fill an AVar. If the AVar is already filled,
// | this will do nothing. Returns true or false depending on if it succeeded.
var tryPut = function (value) {
    return function ($8) {
        return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_AVar.tryPut(value)($8));
    };
};

// | Takes the AVar value, leaving it empty. If the AVar is already empty,
// | the callback will be queued until the AVar is filled. Multiple takes will
// | resolve in order as the AVar fills.
var take = function (avar) {
    return Effect_Aff.makeAff(function (k) {
        return function __do() {
            var v = Effect_AVar.take(avar)(k)();
            return Effect_Aff.effectCanceler(v);
        };
    });
};

// | Synchronously checks the status of an AVar.
var status = function ($9) {
    return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_AVar.status($9));
};

// | Reads the AVar value. Unlike `take`, this will not leave the AVar empty.
// | If the AVar is empty, this will queue until it is filled. Multiple reads
// | will resolve at the same time, as soon as possible.
var read = function (avar) {
    return Effect_Aff.makeAff(function (k) {
        return function __do() {
            var v = Effect_AVar.read(avar)(k)();
            return Effect_Aff.effectCanceler(v);
        };
    });
};

// | Sets the value of the AVar. If the AVar is already filled, it will be
// | queued until the value is emptied. Multiple puts will resolve in order as
// | the AVar becomes available.
var put = function (value) {
    return function (avar) {
        return Effect_Aff.makeAff(function (k) {
            return function __do() {
                var v = Effect_AVar.put(value)(avar)(k)();
                return Effect_Aff.effectCanceler(v);
            };
        });
    };
};

// | Creates a fresh AVar with an initial value.
var $$new = function ($10) {
    return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_AVar["new"]($10));
};

// | Kills the AVar with an exception. All pending and future actions will
// | resolve immediately with the provided exception.
var kill = function (error) {
    return function ($11) {
        return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_AVar.kill(error)($11));
    };
};

// | Creates a fresh AVar.
var empty = Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_AVar.empty);
module.exports = {
    "new": $$new,
    empty: empty,
    status: status,
    take: take,
    tryTake: tryTake,
    put: put,
    tryPut: tryPut,
    read: read,
    tryRead: tryRead,
    kill: kill
};
