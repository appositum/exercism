"use strict";
var $foreign = require("./foreign.js");
var Control_Category = require("../Control.Category/index.js");
var Control_Semigroupoid = require("../Control.Semigroupoid/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Bounded = require("../Data.Bounded/index.js");
var Data_CommutativeRing = require("../Data.CommutativeRing/index.js");
var Data_DivisionRing = require("../Data.DivisionRing/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_EuclideanRing = require("../Data.EuclideanRing/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_Int_Bits = require("../Data.Int.Bits/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Ring = require("../Data.Ring/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");
var Data_Show = require("../Data.Show/index.js");
var Global = require("../Global/index.js");
var $$Math = require("../Math/index.js");
var Prelude = require("../Prelude/index.js");

// | The number of unique digits (including zero) used to represent integers in
// | a specific base.
var Radix = function (x) {
    return x;
};

// | A type for describing whether an integer is even or odd.
// |
// | The `Ord` instance considers `Even` to be less than `Odd`.
// |
// | The `Semiring` instance allows you to ask about the parity of the results
// | of arithmetical operations, given only the parities of the inputs. For
// | example, the sum of an odd number and an even number is odd, so
// | `Odd + Even == Odd`. This also works for multiplication, eg. the product
// | of two odd numbers is odd, and therefore `Odd * Odd == Odd`.
// |
// | More generally, we have that
// |
// | ```purescript
// | parity x + parity y == parity (x + y)
// | parity x * parity y == parity (x * y)
// | ```
// |
// | for any integers `x`, `y`. (A mathematician would say that `parity` is a
// | *ring homomorphism*.)
// |
// | After defining addition and multiplication on `Parity` in this way, the
// | `Semiring` laws now force us to choose `zero = Even` and `one = Odd`.
// | This `Semiring` instance actually turns out to be a `Field`.
var Even = (function () {
    function Even() {

    };
    Even.value = new Even();
    return Even;
})();

// | A type for describing whether an integer is even or odd.
// |
// | The `Ord` instance considers `Even` to be less than `Odd`.
// |
// | The `Semiring` instance allows you to ask about the parity of the results
// | of arithmetical operations, given only the parities of the inputs. For
// | example, the sum of an odd number and an even number is odd, so
// | `Odd + Even == Odd`. This also works for multiplication, eg. the product
// | of two odd numbers is odd, and therefore `Odd * Odd == Odd`.
// |
// | More generally, we have that
// |
// | ```purescript
// | parity x + parity y == parity (x + y)
// | parity x * parity y == parity (x * y)
// | ```
// |
// | for any integers `x`, `y`. (A mathematician would say that `parity` is a
// | *ring homomorphism*.)
// |
// | After defining addition and multiplication on `Parity` in this way, the
// | `Semiring` laws now force us to choose `zero = Even` and `one = Odd`.
// | This `Semiring` instance actually turns out to be a `Field`.
var Odd = (function () {
    function Odd() {

    };
    Odd.value = new Odd();
    return Odd;
})();
var showParity = new Data_Show.Show(function (v) {
    if (v instanceof Even) {
        return "Even";
    };
    if (v instanceof Odd) {
        return "Odd";
    };
    throw new Error("Failed pattern match at Data.Int line 112, column 1 - line 112, column 35: " + [ v.constructor.name ]);
});

// | Create a `Radix` from a number between 2 and 36.
var radix = function (n) {
    if (n >= 2 && n <= 36) {
        return new Data_Maybe.Just(n);
    };
    if (Data_Boolean.otherwise) {
        return Data_Maybe.Nothing.value;
    };
    throw new Error("Failed pattern match at Data.Int line 193, column 1 - line 193, column 28: " + [ n.constructor.name ]);
};

// | The negation of `even`.
// |
// | ``` purescript
// | odd 0 == false
// | odd 1 == true
// | ```
var odd = function (x) {
    return (x & 1) !== 0;
};

// | The base-8 system.
var octal = 8;

// | The base-16 system.
var hexadecimal = 16;

// | Like `fromString`, but the integer can be specified in a different base.
// |
// | Example:
// | ``` purs
// | fromStringAs binary      "100" == Just 4
// | fromStringAs hexadecimal "ff"  == Just 255
// | ```
var fromStringAs = $foreign.fromStringAsImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

// | Reads an `Int` from a `String` value. The number must parse as an integer
// | and fall within the valid range of values for the `Int` type, otherwise
// | `Nothing` is returned.
var fromString = fromStringAs(10);

// | Creates an `Int` from a `Number` value. The number must already be an
// | integer and fall within the valid range of values for the `Int` type
// | otherwise `Nothing` is returned.
var fromNumber = $foreign.fromNumberImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

// | Convert an integral `Number` to an `Int`, by clamping to the `Int` range.
// | This function will return 0 if the input is `NaN` or an `Infinity`.
var unsafeClamp = function (x) {
    if (x === Global.infinity) {
        return 0;
    };
    if (x === -Global.infinity) {
        return 0;
    };
    if (x >= $foreign.toNumber(Data_Bounded.top(Data_Bounded.boundedInt))) {
        return Data_Bounded.top(Data_Bounded.boundedInt);
    };
    if (x <= $foreign.toNumber(Data_Bounded.bottom(Data_Bounded.boundedInt))) {
        return Data_Bounded.bottom(Data_Bounded.boundedInt);
    };
    if (Data_Boolean.otherwise) {
        return Data_Maybe.fromMaybe(0)(fromNumber(x));
    };
    throw new Error("Failed pattern match at Data.Int line 66, column 1 - line 66, column 29: " + [ x.constructor.name ]);
};

// | Convert a `Number` to an `Int`, by taking the nearest integer to the
// | argument. Values outside the `Int` range are clamped, `NaN` and `Infinity`
// | values return 0.
var round = function ($23) {
    return unsafeClamp($$Math.round($23));
};

// | Convert a `Number` to an `Int`, by taking the closest integer equal to or
// | less than the argument. Values outside the `Int` range are clamped, `NaN`
// | and `Infinity` values return 0.
var floor = function ($24) {
    return unsafeClamp($$Math.floor($24));
};

// | Returns whether an `Int` is an even number.
// |
// | ``` purescript
// | even 0 == true
// | even 1 == false
// | ```
var even = function (x) {
    return (x & 1) === 0;
};

// | Returns whether an `Int` is `Even` or `Odd`.
// |
// | ``` purescript
// | parity 0 == Even
// | parity 1 == Odd
// | ```
var parity = function (n) {
    var $14 = even(n);
    if ($14) {
        return Even.value;
    };
    return Odd.value;
};
var eqParity = new Data_Eq.Eq(function (x) {
    return function (y) {
        if (x instanceof Even && y instanceof Even) {
            return true;
        };
        if (x instanceof Odd && y instanceof Odd) {
            return true;
        };
        return false;
    };
});
var ordParity = new Data_Ord.Ord(function () {
    return eqParity;
}, function (x) {
    return function (y) {
        if (x instanceof Even && y instanceof Even) {
            return Data_Ordering.EQ.value;
        };
        if (x instanceof Even) {
            return Data_Ordering.LT.value;
        };
        if (y instanceof Even) {
            return Data_Ordering.GT.value;
        };
        if (x instanceof Odd && y instanceof Odd) {
            return Data_Ordering.EQ.value;
        };
        throw new Error("Failed pattern match at Data.Int line 110, column 8 - line 110, column 40: " + [ x.constructor.name, y.constructor.name ]);
    };
});
var semiringParity = new Data_Semiring.Semiring(function (x) {
    return function (y) {
        var $19 = Data_Eq.eq(eqParity)(x)(y);
        if ($19) {
            return Even.value;
        };
        return Odd.value;
    };
}, function (v) {
    return function (v1) {
        if (v instanceof Odd && v1 instanceof Odd) {
            return Odd.value;
        };
        return Even.value;
    };
}, Odd.value, Even.value);
var ringParity = new Data_Ring.Ring(function () {
    return semiringParity;
}, Data_Semiring.add(semiringParity));
var divisionRingParity = new Data_DivisionRing.DivisionRing(function () {
    return ringParity;
}, Control_Category.identity(Control_Category.categoryFn));

// | The base-10 system.
var decimal = 10;
var commutativeRingParity = new Data_CommutativeRing.CommutativeRing(function () {
    return ringParity;
});
var euclideanRingParity = new Data_EuclideanRing.EuclideanRing(function () {
    return commutativeRingParity;
}, function (v) {
    if (v instanceof Even) {
        return 0;
    };
    if (v instanceof Odd) {
        return 1;
    };
    throw new Error("Failed pattern match at Data.Int line 132, column 1 - line 132, column 53: " + [ v.constructor.name ]);
}, function (x) {
    return function (v) {
        return x;
    };
}, function (v) {
    return function (v1) {
        return Even.value;
    };
});

// | Convert a `Number` to an `Int`, by taking the closest integer equal to or
// | greater than the argument. Values outside the `Int` range are clamped,
// | `NaN` and `Infinity` values return 0.
var ceil = function ($25) {
    return unsafeClamp($$Math.ceil($25));
};
var boundedParity = new Data_Bounded.Bounded(function () {
    return ordParity;
}, Even.value, Odd.value);

// | The base-2 system.
var binary = 2;

// | The base-36 system.
var base36 = 36;
module.exports = {
    fromNumber: fromNumber,
    ceil: ceil,
    floor: floor,
    round: round,
    fromString: fromString,
    radix: radix,
    binary: binary,
    octal: octal,
    decimal: decimal,
    hexadecimal: hexadecimal,
    base36: base36,
    fromStringAs: fromStringAs,
    Even: Even,
    Odd: Odd,
    parity: parity,
    even: even,
    odd: odd,
    eqParity: eqParity,
    ordParity: ordParity,
    showParity: showParity,
    boundedParity: boundedParity,
    semiringParity: semiringParity,
    ringParity: ringParity,
    commutativeRingParity: commutativeRingParity,
    euclideanRingParity: euclideanRingParity,
    divisionRingParity: divisionRingParity,
    toNumber: $foreign.toNumber,
    toStringAs: $foreign.toStringAs,
    quot: $foreign.quot,
    rem: $foreign.rem,
    pow: $foreign.pow
};
