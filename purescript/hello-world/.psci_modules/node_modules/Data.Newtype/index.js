"use strict";
var Control_Semigroupoid = require("../Control.Semigroupoid/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Monoid_Additive = require("../Data.Monoid.Additive/index.js");
var Data_Monoid_Conj = require("../Data.Monoid.Conj/index.js");
var Data_Monoid_Disj = require("../Data.Monoid.Disj/index.js");
var Data_Monoid_Dual = require("../Data.Monoid.Dual/index.js");
var Data_Monoid_Endo = require("../Data.Monoid.Endo/index.js");
var Data_Monoid_Multiplicative = require("../Data.Monoid.Multiplicative/index.js");
var Data_Semigroup_First = require("../Data.Semigroup.First/index.js");
var Data_Semigroup_Last = require("../Data.Semigroup.Last/index.js");
var Prelude = require("../Prelude/index.js");

// | A type class for `newtype`s to enable convenient wrapping and unwrapping,
// | and the use of the other functions in this module.
// |
// | The compiler can derive instances of `Newtype` automatically:
// |
// | ``` purescript
// | newtype EmailAddress = EmailAddress String
// |
// | derive instance newtypeEmailAddress :: Newtype EmailAddress _
// | ```
// |
// | Note that deriving for `Newtype` instances requires that the type be
// | defined as `newtype` rather than `data` declaration (even if the `data`
// | structurally fits the rules of a `newtype`), and the use of a wildcard for
// | the wrapped type.
// |
// | Instances must obey the following laws:
// | ``` purescript
// | unwrap <<< wrap = id
// | wrap <<< unwrap = id
// | ```
var Newtype = function (unwrap, wrap) {
    this.unwrap = unwrap;
    this.wrap = wrap;
};
var wrap = function (dict) {
    return dict.wrap;
};
var unwrap = function (dict) {
    return dict.unwrap;
};

// | Much like `under2`, but where the lifted binary function operates on
// | values in a `Functor`.
var underF2 = function (dictFunctor) {
    return function (dictFunctor1) {
        return function (dictNewtype) {
            return function (dictNewtype1) {
                return function (v) {
                    return function (f) {
                        return function ($66) {
                            return function ($67) {
                                return Data_Functor.map(dictFunctor1)(unwrap(dictNewtype1))(Data_Function.on(f)(Data_Functor.map(dictFunctor)(wrap(dictNewtype)))($66)($67));
                            };
                        };
                    };
                };
            };
        };
    };
};

// | Much like `under`, but where the lifted function operates on values in a
// | `Functor`:
// |
// | ``` purescript
// | newtype EmailAddress = EmailAddress String
// | derive instance newtypeEmailAddress :: Newtype EmailAddress _
// |
// | isValid :: EmailAddress -> Boolean
// | isValid x = false -- imagine a slightly less strict predicate here
// |
// | findValidEmailString :: Array String -> Maybe String
// | findValidEmailString = underF EmailAddress (Foldable.find isValid)
// | ```
// |
// | The above example also demonstrates that the functor type is polymorphic
// | here too, the input is an `Array` but the result is a `Maybe`.
var underF = function (dictFunctor) {
    return function (dictFunctor1) {
        return function (dictNewtype) {
            return function (dictNewtype1) {
                return function (v) {
                    return function (f) {
                        return function ($68) {
                            return Data_Functor.map(dictFunctor1)(unwrap(dictNewtype1))(f(Data_Functor.map(dictFunctor)(wrap(dictNewtype))($68)));
                        };
                    };
                };
            };
        };
    };
};

// | The opposite of `over2`: lowers a binary function that operates on `Newtype`d
// | values to operate on the wrapped value instead.
var under2 = function (dictNewtype) {
    return function (dictNewtype1) {
        return function (v) {
            return function (f) {
                return function ($69) {
                    return function ($70) {
                        return unwrap(dictNewtype1)(Data_Function.on(f)(wrap(dictNewtype))($69)($70));
                    };
                };
            };
        };
    };
};

// | The opposite of `over`: lowers a function that operates on `Newtype`d
// | values to operate on the wrapped value instead.
// |
// | ``` purescript
// | newtype Degrees = Degrees Number
// | derive instance newtypeDegrees :: Newtype Degrees _
// |
// | newtype NormalDegrees = NormalDegrees Number
// | derive instance newtypeNormalDegrees :: Newtype NormalDegrees _
// |
// | normaliseDegrees :: Degrees -> NormalDegrees
// | normaliseDegrees (Degrees deg) = NormalDegrees (deg % 360.0)
// |
// | asNormalDegrees :: Number -> Number
// | asNormalDegrees = under Degrees normaliseDegrees
// | ```
// |
// | As with `over` the `Newtype` is polymorphic, as illustrated in the example
// | above - both `Degrees` and `NormalDegrees` are instances of `Newtype`,
// | so even though `normaliseDegrees` changes the result type we can still put
// | a `Number` in and get a `Number` out via `under`.
var under = function (dictNewtype) {
    return function (dictNewtype1) {
        return function (v) {
            return function (f) {
                return function ($71) {
                    return unwrap(dictNewtype1)(f(wrap(dictNewtype)($71)));
                };
            };
        };
    };
};

// | Given a constructor for a `Newtype`, this returns the appropriate `unwrap`
// | function.
var un = function (dictNewtype) {
    return function (v) {
        return unwrap(dictNewtype);
    };
};

// | Similar to the function from the `Traversable` class, but operating within
// | a newtype instead.
var traverse = function (dictFunctor) {
    return function (dictNewtype) {
        return function (v) {
            return function (f) {
                return function ($72) {
                    return Data_Functor.map(dictFunctor)(wrap(dictNewtype))(f(unwrap(dictNewtype)($72)));
                };
            };
        };
    };
};

// | Much like `over2`, but where the lifted binary function operates on
// | values in a `Functor`.
var overF2 = function (dictFunctor) {
    return function (dictFunctor1) {
        return function (dictNewtype) {
            return function (dictNewtype1) {
                return function (v) {
                    return function (f) {
                        return function ($73) {
                            return function ($74) {
                                return Data_Functor.map(dictFunctor1)(wrap(dictNewtype1))(Data_Function.on(f)(Data_Functor.map(dictFunctor)(unwrap(dictNewtype)))($73)($74));
                            };
                        };
                    };
                };
            };
        };
    };
};

// | Much like `over`, but where the lifted function operates on values in a
// | `Functor`:
// |
// | ``` purescript
// | findLabel :: String -> Array Label -> Maybe Label
// | findLabel s = overF Label (Foldable.find (_ == s))
// | ```
// |
// | The above example also demonstrates that the functor type is polymorphic
// | here too, the input is an `Array` but the result is a `Maybe`.
var overF = function (dictFunctor) {
    return function (dictFunctor1) {
        return function (dictNewtype) {
            return function (dictNewtype1) {
                return function (v) {
                    return function (f) {
                        return function ($75) {
                            return Data_Functor.map(dictFunctor1)(wrap(dictNewtype1))(f(Data_Functor.map(dictFunctor)(unwrap(dictNewtype))($75)));
                        };
                    };
                };
            };
        };
    };
};

// | Lifts a binary function to operate over newtypes.
// |
// | ``` purescript
// | newtype Meter = Meter Int
// | derive newtype instance newtypeMeter :: Newtype Meter _
// | newtype SquareMeter = SquareMeter Int
// | derive newtype instance newtypeSquareMeter :: Newtype SquareMeter _
// |
// | area :: Meter -> Meter -> SquareMeter
// | area = over2 Meter (*)
// | ```
// |
// | The above example also demonstrates that the return type is polymorphic
// | here too.
var over2 = function (dictNewtype) {
    return function (dictNewtype1) {
        return function (v) {
            return function (f) {
                return function ($76) {
                    return function ($77) {
                        return wrap(dictNewtype1)(Data_Function.on(f)(unwrap(dictNewtype))($76)($77));
                    };
                };
            };
        };
    };
};

// | Lifts a function operate over newtypes. This can be used to lift a
// | function to manipulate the contents of a single newtype, somewhat like
// | `map` does for a `Functor`:
// |
// | ``` purescript
// | newtype Label = Label String
// | derive instance newtypeLabel :: Newtype Label _
// |
// | toUpperLabel :: Label -> Label
// | toUpperLabel = over Label String.toUpper
// | ```
// |
// | But the result newtype is polymorphic, meaning the result can be returned
// | as an alternative newtype:
// |
// | ``` purescript
// | newtype UppercaseLabel = UppercaseLabel String
// | derive instance newtypeUppercaseLabel :: Newtype UppercaseLabel _
// |
// | toUpperLabel' :: Label -> UppercaseLabel
// | toUpperLabel' = over Label String.toUpper
// | ```
var over = function (dictNewtype) {
    return function (dictNewtype1) {
        return function (v) {
            return function (f) {
                return function ($78) {
                    return wrap(dictNewtype1)(f(unwrap(dictNewtype)($78)));
                };
            };
        };
    };
};

// | Deprecated previous name of `un`.
var op = function (dictNewtype) {
    return un(dictNewtype);
};
var newtypeMultiplicative = new Newtype(function (v) {
    return v;
}, Data_Monoid_Multiplicative.Multiplicative);
var newtypeLast = new Newtype(function (v) {
    return v;
}, Data_Semigroup_Last.Last);
var newtypeFirst = new Newtype(function (v) {
    return v;
}, Data_Semigroup_First.First);
var newtypeEndo = new Newtype(function (v) {
    return v;
}, Data_Monoid_Endo.Endo);
var newtypeDual = new Newtype(function (v) {
    return v;
}, Data_Monoid_Dual.Dual);
var newtypeDisj = new Newtype(function (v) {
    return v;
}, Data_Monoid_Disj.Disj);
var newtypeConj = new Newtype(function (v) {
    return v;
}, Data_Monoid_Conj.Conj);
var newtypeAdditive = new Newtype(function (v) {
    return v;
}, Data_Monoid_Additive.Additive);

// | Similar to the function from the `Distributive` class, but operating within
// | a newtype instead.
var collect = function (dictFunctor) {
    return function (dictNewtype) {
        return function (v) {
            return function (f) {
                return function ($79) {
                    return wrap(dictNewtype)(f(Data_Functor.map(dictFunctor)(unwrap(dictNewtype))($79)));
                };
            };
        };
    };
};

// | Similar to `ala` but useful for cases where you want to use an additional
// | projection with the higher order function:
// |
// | ``` purescript
// | alaF Additive foldMap String.length ["hello", "world"] -- 10
// | alaF Multiplicative foldMap Math.abs [1.0, -2.0, 3.0, -4.0] -- 24.0
// | ```
// |
// | The type admits other possibilities due to the polymorphic `Functor`
// | constraints, but the case described above works because ((->) a) is a
// | `Functor`.
var alaF = function (dictFunctor) {
    return function (dictFunctor1) {
        return function (dictNewtype) {
            return function (dictNewtype1) {
                return function (v) {
                    return function (f) {
                        return function ($80) {
                            return Data_Functor.map(dictFunctor1)(unwrap(dictNewtype1))(f(Data_Functor.map(dictFunctor)(wrap(dictNewtype))($80)));
                        };
                    };
                };
            };
        };
    };
};

// | This combinator is for when you have a higher order function that you want
// | to use in the context of some newtype - `foldMap` being a common example:
// |
// | ``` purescript
// | ala Additive foldMap [1,2,3,4] -- 10
// | ala Multiplicative foldMap [1,2,3,4] -- 24
// | ala Conj foldMap [true, false] -- false
// | ala Disj foldMap [true, false] -- true
// | ```
var ala = function (dictFunctor) {
    return function (dictNewtype) {
        return function (dictNewtype1) {
            return function (v) {
                return function (f) {
                    return Data_Functor.map(dictFunctor)(unwrap(dictNewtype))(f(wrap(dictNewtype1)));
                };
            };
        };
    };
};
module.exports = {
    unwrap: unwrap,
    wrap: wrap,
    Newtype: Newtype,
    un: un,
    op: op,
    ala: ala,
    alaF: alaF,
    over: over,
    overF: overF,
    under: under,
    underF: underF,
    over2: over2,
    overF2: overF2,
    under2: under2,
    underF2: underF2,
    traverse: traverse,
    collect: collect,
    newtypeAdditive: newtypeAdditive,
    newtypeMultiplicative: newtypeMultiplicative,
    newtypeConj: newtypeConj,
    newtypeDisj: newtypeDisj,
    newtypeDual: newtypeDual,
    newtypeEndo: newtypeEndo,
    newtypeFirst: newtypeFirst,
    newtypeLast: newtypeLast
};
