"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Extend = require("../Control.Extend/index.js");
var Control_Monad = require("../Control.Monad/index.js");
var Control_Semigroupoid = require("../Control.Semigroupoid/index.js");
var Data_Bifoldable = require("../Data.Bifoldable/index.js");
var Data_Bifunctor = require("../Data.Bifunctor/index.js");
var Data_Bitraversable = require("../Data.Bitraversable/index.js");
var Data_Bounded = require("../Data.Bounded/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Functor_Invariant = require("../Data.Functor.Invariant/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Prelude = require("../Prelude/index.js");

// | The `Either` type is used to represent a choice between two types of value.
// |
// | A common use case for `Either` is error handling, where `Left` is used to
// | carry an error value and `Right` is used to carry a success value.
var Left = (function () {
    function Left(value0) {
        this.value0 = value0;
    };
    Left.create = function (value0) {
        return new Left(value0);
    };
    return Left;
})();

// | The `Either` type is used to represent a choice between two types of value.
// |
// | A common use case for `Either` is error handling, where `Left` is used to
// | carry an error value and `Right` is used to carry a success value.
var Right = (function () {
    function Right(value0) {
        this.value0 = value0;
    };
    Right.create = function (value0) {
        return new Right(value0);
    };
    return Right;
})();

// | The `Show` instance allows `Either` values to be rendered as a string with
// | `show` whenever there is an `Show` instance for both type the `Either` can
// | contain.
var showEither = function (dictShow) {
    return function (dictShow1) {
        return new Data_Show.Show(function (v) {
            if (v instanceof Left) {
                return "(Left " + (Data_Show.show(dictShow)(v.value0) + ")");
            };
            if (v instanceof Right) {
                return "(Right " + (Data_Show.show(dictShow1)(v.value0) + ")");
            };
            throw new Error("Failed pattern match at Data.Either line 157, column 1 - line 157, column 61: " + [ v.constructor.name ]);
        });
    };
};

// | Similar to `note`, but for use in cases where the default value may be
// | expensive to compute.
// |
// | ```purescript
// | note' (\_ -> "default") Nothing = Left "default"
// | note' (\_ -> "default") (Just 1) = Right 1
// | ```
var note$prime = function (f) {
    return Data_Maybe["maybe'"](function ($171) {
        return Left.create(f($171));
    })(Right.create);
};

// | Takes a default and a `Maybe` value, if the value is a `Just`, turn it into
// | a `Right`, if the value is a `Nothing` use the provided default as a `Left`
// |
// | ```purescript
// | note "default" Nothing = Left "default"
// | note "default" (Just 1) = Right 1
// | ```
var note = function (a) {
    return Data_Maybe.maybe(new Left(a))(Right.create);
};
var functorEither = new Data_Functor.Functor(function (f) {
    return function (m) {
        if (m instanceof Left) {
            return new Left(m.value0);
        };
        if (m instanceof Right) {
            return new Right(f(m.value0));
        };
        throw new Error("Failed pattern match at Data.Either line 35, column 8 - line 35, column 52: " + [ m.constructor.name ]);
    };
});
var invariantEither = new Data_Functor_Invariant.Invariant(Data_Functor_Invariant.imapF(functorEither));

// | A partial function that extracts the value from the `Right` data constructor.
// | Passing a `Left` to `fromRight` will throw an error at runtime.
var fromRight = function (dictPartial) {
    return function (v) {
        var $__unused = function (dictPartial1) {
            return function ($dollar63) {
                return $dollar63;
            };
        };
        return $__unused(dictPartial)((function () {
            if (v instanceof Right) {
                return v.value0;
            };
            throw new Error("Failed pattern match at Data.Either line 243, column 1 - line 243, column 52: " + [ v.constructor.name ]);
        })());
    };
};

// | A partial function that extracts the value from the `Left` data constructor.
// | Passing a `Right` to `fromLeft` will throw an error at runtime.
var fromLeft = function (dictPartial) {
    return function (v) {
        var $__unused = function (dictPartial1) {
            return function ($dollar67) {
                return $dollar67;
            };
        };
        return $__unused(dictPartial)((function () {
            if (v instanceof Left) {
                return v.value0;
            };
            throw new Error("Failed pattern match at Data.Either line 238, column 1 - line 238, column 51: " + [ v.constructor.name ]);
        })());
    };
};
var foldableEither = new Data_Foldable.Foldable(function (dictMonoid) {
    return function (f) {
        return function (v) {
            if (v instanceof Left) {
                return Data_Monoid.mempty(dictMonoid);
            };
            if (v instanceof Right) {
                return f(v.value0);
            };
            throw new Error("Failed pattern match at Data.Either line 181, column 1 - line 181, column 47: " + [ f.constructor.name, v.constructor.name ]);
        };
    };
}, function (v) {
    return function (z) {
        return function (v1) {
            if (v1 instanceof Left) {
                return z;
            };
            if (v1 instanceof Right) {
                return v(z)(v1.value0);
            };
            throw new Error("Failed pattern match at Data.Either line 181, column 1 - line 181, column 47: " + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);
        };
    };
}, function (v) {
    return function (z) {
        return function (v1) {
            if (v1 instanceof Left) {
                return z;
            };
            if (v1 instanceof Right) {
                return v(v1.value0)(z);
            };
            throw new Error("Failed pattern match at Data.Either line 181, column 1 - line 181, column 47: " + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);
        };
    };
});
var traversableEither = new Data_Traversable.Traversable(function () {
    return foldableEither;
}, function () {
    return functorEither;
}, function (dictApplicative) {
    return function (v) {
        if (v instanceof Left) {
            return Control_Applicative.pure(dictApplicative)(new Left(v.value0));
        };
        if (v instanceof Right) {
            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Right.create)(v.value0);
        };
        throw new Error("Failed pattern match at Data.Either line 197, column 1 - line 197, column 53: " + [ v.constructor.name ]);
    };
}, function (dictApplicative) {
    return function (v) {
        return function (v1) {
            if (v1 instanceof Left) {
                return Control_Applicative.pure(dictApplicative)(new Left(v1.value0));
            };
            if (v1 instanceof Right) {
                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Right.create)(v(v1.value0));
            };
            throw new Error("Failed pattern match at Data.Either line 197, column 1 - line 197, column 53: " + [ v.constructor.name, v1.constructor.name ]);
        };
    };
});

// | The `Extend` instance allows sequencing of `Either` values and functions
// | that accept an `Either` and return a non-`Either` result using the
// | `<<=` operator.
// |
// | ``` purescript
// | f <<= Left x = Left x
// | f <<= Right x = Right (f (Right x))
// | ```
var extendEither = new Control_Extend.Extend(function () {
    return functorEither;
}, function (v) {
    return function (v1) {
        if (v1 instanceof Left) {
            return new Left(v1.value0);
        };
        return new Right(v(v1));
    };
});
var eqEither = function (dictEq) {
    return function (dictEq1) {
        return new Data_Eq.Eq(function (x) {
            return function (y) {
                if (x instanceof Left && y instanceof Left) {
                    return Data_Eq.eq(dictEq)(x.value0)(y.value0);
                };
                if (x instanceof Right && y instanceof Right) {
                    return Data_Eq.eq(dictEq1)(x.value0)(y.value0);
                };
                return false;
            };
        });
    };
};
var ordEither = function (dictOrd) {
    return function (dictOrd1) {
        return new Data_Ord.Ord(function () {
            return eqEither(dictOrd.Eq0())(dictOrd1.Eq0());
        }, function (x) {
            return function (y) {
                if (x instanceof Left && y instanceof Left) {
                    return Data_Ord.compare(dictOrd)(x.value0)(y.value0);
                };
                if (x instanceof Left) {
                    return Data_Ordering.LT.value;
                };
                if (y instanceof Left) {
                    return Data_Ordering.GT.value;
                };
                if (x instanceof Right && y instanceof Right) {
                    return Data_Ord.compare(dictOrd1)(x.value0)(y.value0);
                };
                throw new Error("Failed pattern match at Data.Either line 173, column 8 - line 173, column 64: " + [ x.constructor.name, y.constructor.name ]);
            };
        });
    };
};
var eq1Either = function (dictEq) {
    return new Data_Eq.Eq1(function (dictEq1) {
        return Data_Eq.eq(eqEither(dictEq)(dictEq1));
    });
};
var ord1Either = function (dictOrd) {
    return new Data_Ord.Ord1(function () {
        return eq1Either(dictOrd.Eq0());
    }, function (dictOrd1) {
        return Data_Ord.compare(ordEither(dictOrd)(dictOrd1));
    });
};

// | Takes two functions and an `Either` value, if the value is a `Left` the
// | inner value is applied to the first function, if the value is a `Right`
// | the inner value is applied to the second function.
// |
// | ``` purescript
// | either f g (Left x) == f x
// | either f g (Right y) == g y
// | ```
var either = function (v) {
    return function (v1) {
        return function (v2) {
            if (v2 instanceof Left) {
                return v(v2.value0);
            };
            if (v2 instanceof Right) {
                return v1(v2.value0);
            };
            throw new Error("Failed pattern match at Data.Either line 220, column 1 - line 220, column 64: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
        };
    };
};

// | Turns an `Either` into a `Maybe`, by throwing eventual `Left` values away and converting
// | them into `Nothing`. `Right` values get turned into `Just`s.
// |
// | ```purescript
// | hush (Left "ParseError") = Nothing
// | hush (Right 42) = Just 42
// | ```
var hush = either(Data_Function["const"](Data_Maybe.Nothing.value))(Data_Maybe.Just.create);

// | Returns `true` when the `Either` value was constructed with `Left`.
var isLeft = either(Data_Function["const"](true))(Data_Function["const"](false));

// | Returns `true` when the `Either` value was constructed with `Right`.
var isRight = either(Data_Function["const"](false))(Data_Function["const"](true));

// | Combine two alternatives.
var choose = function (dictAlt) {
    return function (a) {
        return function (b) {
            return Control_Alt.alt(dictAlt)(Data_Functor.map(dictAlt.Functor0())(Left.create)(a))(Data_Functor.map(dictAlt.Functor0())(Right.create)(b));
        };
    };
};
var boundedEither = function (dictBounded) {
    return function (dictBounded1) {
        return new Data_Bounded.Bounded(function () {
            return ordEither(dictBounded.Ord0())(dictBounded1.Ord0());
        }, new Left(Data_Bounded.bottom(dictBounded)), new Right(Data_Bounded.top(dictBounded1)));
    };
};
var bifunctorEither = new Data_Bifunctor.Bifunctor(function (v) {
    return function (v1) {
        return function (v2) {
            if (v2 instanceof Left) {
                return new Left(v(v2.value0));
            };
            if (v2 instanceof Right) {
                return new Right(v1(v2.value0));
            };
            throw new Error("Failed pattern match at Data.Either line 40, column 1 - line 40, column 45: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
        };
    };
});
var bifoldableEither = new Data_Bifoldable.Bifoldable(function (dictMonoid) {
    return function (v) {
        return function (v1) {
            return function (v2) {
                if (v2 instanceof Left) {
                    return v(v2.value0);
                };
                if (v2 instanceof Right) {
                    return v1(v2.value0);
                };
                throw new Error("Failed pattern match at Data.Either line 189, column 1 - line 189, column 47: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
            };
        };
    };
}, function (v) {
    return function (v1) {
        return function (z) {
            return function (v2) {
                if (v2 instanceof Left) {
                    return v(z)(v2.value0);
                };
                if (v2 instanceof Right) {
                    return v1(z)(v2.value0);
                };
                throw new Error("Failed pattern match at Data.Either line 189, column 1 - line 189, column 47: " + [ v.constructor.name, v1.constructor.name, z.constructor.name, v2.constructor.name ]);
            };
        };
    };
}, function (v) {
    return function (v1) {
        return function (z) {
            return function (v2) {
                if (v2 instanceof Left) {
                    return v(v2.value0)(z);
                };
                if (v2 instanceof Right) {
                    return v1(v2.value0)(z);
                };
                throw new Error("Failed pattern match at Data.Either line 189, column 1 - line 189, column 47: " + [ v.constructor.name, v1.constructor.name, z.constructor.name, v2.constructor.name ]);
            };
        };
    };
});
var bitraversableEither = new Data_Bitraversable.Bitraversable(function () {
    return bifoldableEither;
}, function () {
    return bifunctorEither;
}, function (dictApplicative) {
    return function (v) {
        if (v instanceof Left) {
            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Left.create)(v.value0);
        };
        if (v instanceof Right) {
            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Right.create)(v.value0);
        };
        throw new Error("Failed pattern match at Data.Either line 203, column 1 - line 203, column 53: " + [ v.constructor.name ]);
    };
}, function (dictApplicative) {
    return function (v) {
        return function (v1) {
            return function (v2) {
                if (v2 instanceof Left) {
                    return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Left.create)(v(v2.value0));
                };
                if (v2 instanceof Right) {
                    return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Right.create)(v1(v2.value0));
                };
                throw new Error("Failed pattern match at Data.Either line 203, column 1 - line 203, column 53: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
            };
        };
    };
});

// | The `Apply` instance allows functions contained within a `Right` to
// | transform a value contained within a `Right` using the `(<*>)` operator:
// |
// | ``` purescript
// | Right f <*> Right x == Right (f x)
// | ```
// |
// | `Left` values are left untouched:
// |
// | ``` purescript
// | Left f <*> Right x == Left x
// | Right f <*> Left y == Left y
// | ```
// |
// | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used to transform a
// | pure function to take `Either`-typed arguments so `f :: a -> b -> c`
// | becomes `f :: Either l a -> Either l b -> Either l c`:
// |
// | ``` purescript
// | f <$> Right x <*> Right y == Right (f x y)
// | ```
// |
// | The `Left`-preserving behaviour of both operators means the result of
// | an expression like the above but where any one of the values is `Left`
// | means the whole result becomes `Left` also, taking the first `Left` value
// | found:
// |
// | ``` purescript
// | f <$> Left x <*> Right y == Left x
// | f <$> Right x <*> Left y == Left y
// | f <$> Left x <*> Left y == Left x
// | ```
var applyEither = new Control_Apply.Apply(function () {
    return functorEither;
}, function (v) {
    return function (v1) {
        if (v instanceof Left) {
            return new Left(v.value0);
        };
        if (v instanceof Right) {
            return Data_Functor.map(functorEither)(v.value0)(v1);
        };
        throw new Error("Failed pattern match at Data.Either line 76, column 1 - line 76, column 41: " + [ v.constructor.name, v1.constructor.name ]);
    };
});

// | The `Bind` instance allows sequencing of `Either` values and functions that
// | return an `Either` by using the `>>=` operator:
// |
// | ``` purescript
// | Left x >>= f = Left x
// | Right x >>= f = f x
// | ```
var bindEither = new Control_Bind.Bind(function () {
    return applyEither;
}, either(function (e) {
    return function (v) {
        return new Left(e);
    };
})(function (a) {
    return function (f) {
        return f(a);
    };
}));
var semigroupEither = function (dictSemigroup) {
    return new Data_Semigroup.Semigroup(function (x) {
        return function (y) {
            return Control_Apply.apply(applyEither)(Data_Functor.map(functorEither)(Data_Semigroup.append(dictSemigroup))(x))(y);
        };
    });
};

// | The `Applicative` instance enables lifting of values into `Either` with the
// | `pure` function:
// |
// | ``` purescript
// | pure x :: Either _ _ == Right x
// | ```
// |
// | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s
// | `pure` can be used to pass a mixture of `Either` and non-`Either` typed
// | values to a function that does not usually expect them, by using `pure`
// | for any value that is not already `Either` typed:
// |
// | ``` purescript
// | f <$> Right x <*> pure y == Right (f x y)
// | ```
// |
// | Even though `pure = Right` it is recommended to use `pure` in situations
// | like this as it allows the choice of `Applicative` to be changed later
// | without having to go through and replace `Right` with a new constructor.
var applicativeEither = new Control_Applicative.Applicative(function () {
    return applyEither;
}, Right.create);

// | The `Monad` instance guarantees that there are both `Applicative` and
// | `Bind` instances for `Either`. This also enables the `do` syntactic sugar:
// |
// | ``` purescript
// | do
// |   x' <- x
// |   y' <- y
// |   pure (f x' y')
// | ```
// |
// | Which is equivalent to:
// |
// | ``` purescript
// | x >>= (\x' -> y >>= (\y' -> pure (f x' y')))
// | ```
var monadEither = new Control_Monad.Monad(function () {
    return applicativeEither;
}, function () {
    return bindEither;
});

// | The `Alt` instance allows for a choice to be made between two `Either`
// | values with the `<|>` operator, where the first `Right` encountered
// | is taken.
// |
// | ``` purescript
// | Right x <|> Right y == Right x
// | Left x <|> Right y == Right y
// | Left x <|> Left y == Left y
// | ```
var altEither = new Control_Alt.Alt(function () {
    return functorEither;
}, function (v) {
    return function (v1) {
        if (v instanceof Left) {
            return v1;
        };
        return v;
    };
});
module.exports = {
    Left: Left,
    Right: Right,
    either: either,
    choose: choose,
    isLeft: isLeft,
    isRight: isRight,
    fromLeft: fromLeft,
    fromRight: fromRight,
    note: note,
    "note'": note$prime,
    hush: hush,
    functorEither: functorEither,
    invariantEither: invariantEither,
    bifunctorEither: bifunctorEither,
    applyEither: applyEither,
    applicativeEither: applicativeEither,
    altEither: altEither,
    bindEither: bindEither,
    monadEither: monadEither,
    extendEither: extendEither,
    showEither: showEither,
    eqEither: eqEither,
    eq1Either: eq1Either,
    ordEither: ordEither,
    ord1Either: ord1Either,
    boundedEither: boundedEither,
    foldableEither: foldableEither,
    bifoldableEither: bifoldableEither,
    traversableEither: traversableEither,
    bitraversableEither: bitraversableEither,
    semigroupEither: semigroupEither
};
