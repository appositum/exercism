"use strict";
var Data_EuclideanRing = require("../Data.EuclideanRing/index.js");
var Data_Ring = require("../Data.Ring/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");

// | The `DivisionRing` class is for non-zero rings in which every non-zero
// | element has a multiplicative inverse. Division rings are sometimes also
// | called *skew fields*.
// |
// | Instances must satisfy the following laws in addition to the `Ring` laws:
// |
// | - Non-zero ring: `one /= zero`
// | - Non-zero multiplicative inverse: `recip a * a = a * recip a = one` for
// |   all non-zero `a`
// |
// | The result of `recip zero` is left undefined; individual instances may
// | choose how to handle this case.
// |
// | If a type has both `DivisionRing` and `CommutativeRing` instances, then
// | it is a field and should have a `Field` instance.
var DivisionRing = function (Ring0, recip) {
    this.Ring0 = Ring0;
    this.recip = recip;
};
var recip = function (dict) {
    return dict.recip;
};

// | Right division, defined as `rightDiv a b = a * recip b`. Left and right
// | division are distinct in this module because a `DivisionRing` is not
// | necessarily commutative.
// |
// | If the type `a` is also a `EuclideanRing`, then this function is
// | equivalent to `div` from the `EuclideanRing` class. When working
// | abstractly, `div` should generally be preferred, unless you know that you
// | need your code to work with noncommutative rings.
var rightDiv = function (dictDivisionRing) {
    return function (a) {
        return function (b) {
            return Data_Semiring.mul((dictDivisionRing.Ring0()).Semiring0())(a)(recip(dictDivisionRing)(b));
        };
    };
};

// | Left division, defined as `leftDiv a b = recip b * a`. Left and right
// | division are distinct in this module because a `DivisionRing` is not
// | necessarily commutative.
// |
// | If the type `a` is also a `EuclideanRing`, then this function is
// | equivalent to `div` from the `EuclideanRing` class. When working
// | abstractly, `div` should generally be preferred, unless you know that you
// | need your code to work with noncommutative rings.
var leftDiv = function (dictDivisionRing) {
    return function (a) {
        return function (b) {
            return Data_Semiring.mul((dictDivisionRing.Ring0()).Semiring0())(recip(dictDivisionRing)(b))(a);
        };
    };
};
var divisionringNumber = new DivisionRing(function () {
    return Data_Ring.ringNumber;
}, function (x) {
    return 1.0 / x;
});
module.exports = {
    DivisionRing: DivisionRing,
    recip: recip,
    leftDiv: leftDiv,
    rightDiv: rightDiv,
    divisionringNumber: divisionringNumber
};
