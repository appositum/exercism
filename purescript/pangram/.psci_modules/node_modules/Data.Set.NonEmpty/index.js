"use strict";
var Control_Category = require("../Control.Category/index.js");
var Control_Semigroupoid = require("../Control.Semigroupoid/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_NonEmpty = require("../Data.List.NonEmpty/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Semigroup_Foldable = require("../Data.Semigroup.Foldable/index.js");
var Data_Set = require("../Data.Set/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var Data_Unfoldable1 = require("../Data.Unfoldable1/index.js");
var Partial_Unsafe = require("../Partial.Unsafe/index.js");
var Prelude = require("../Prelude/index.js");

// | `NonEmptySet a` represents a non-empty set of values of type `a`
var NonEmptySet = function (x) {
    return x;
};

// | Form the union of a set and the non-empty set.
var unionSet = function (dictOrd) {
    return function (s1) {
        return function (v) {
            return Data_Semigroup.append(Data_Set.semigroupSet(dictOrd))(s1)(v);
        };
    };
};

// | Convert a set to a non-empty unfoldable structure.
var toUnfoldable1 = function (dictUnfoldable1) {
    return function (v) {
        var go = function (v1) {
            var $__unused = function (dictPartial1) {
                return function ($dollar24) {
                    return $dollar24;
                };
            };
            return $__unused()((function () {
                if (v1 instanceof Data_List_Types.Cons && v1.value1 instanceof Data_List_Types.Nil) {
                    return new Data_Tuple.Tuple(v1.value0, Data_Maybe.Nothing.value);
                };
                if (v1 instanceof Data_List_Types.Cons) {
                    return new Data_Tuple.Tuple(v1.value0, new Data_Maybe.Just(v1.value1));
                };
                throw new Error("Failed pattern match at Data.Set.NonEmpty line 93, column 24 - line 95, column 38: " + [ v1.constructor.name ]);
            })());
        };
        return Data_Unfoldable1.unfoldr1(dictUnfoldable1)(go)(Data_Set.toUnfoldable(Data_List_Types.unfoldableList)(v));
    };
};

// | Convert a set to an unfoldable structure.
var toUnfoldable = function (dictUnfoldable) {
    return function (v) {
        return Data_Set.toUnfoldable(dictUnfoldable)(v);
    };
};

// | Forgets the non-empty property of a set, giving a normal possibly-empty
// | set.
var toSet = function (v) {
    return v;
};

// | True if and only if every element in the first set is an element of the
// | second set.
var subset = function (dictOrd) {
    return function (v) {
        return function (v1) {
            return Data_Set.subset(dictOrd)(v)(v1);
        };
    };
};

// | Find the size of a set.
var size = function (v) {
    return Data_Set.size(v);
};

// | Create a set with one element.
var singleton = function (a) {
    return Data_Set.singleton(a);
};
var showNonEmptySet = function (dictShow) {
    return new Data_Show.Show(function (s) {
        return "(fromFoldable1 " + (Data_Show.show(Data_List_Types.showNonEmptyList(dictShow))(toUnfoldable1(Data_List_Types.unfoldable1NonEmptyList)(s)) + ")");
    });
};
var semigroupNonEmptySet = function (dictOrd) {
    return Data_Set.semigroupSet(dictOrd);
};

// | True if and only if the first set is a subset of the second set and the
// | sets are not equal.
var properSubset = function (dictOrd) {
    return function (v) {
        return function (v1) {
            return Data_Set.properSubset(dictOrd)(v)(v1);
        };
    };
};
var ordNonEmptySet = function (dictOrd) {
    return Data_Set.ordSet(dictOrd);
};
var ord1NonEmptySet = Data_Set.ord1Set;

// | The minimum value in the set.
var min = function (v) {
    return Data_Maybe.fromJust()(Data_Set.findMin(v));
};

// | Test if a value is a member of a set.
var member = function (dictOrd) {
    return function (a) {
        return function (v) {
            return Data_Set.member(dictOrd)(a)(v);
        };
    };
};

// | The maximum value in the set.
var max = function (v) {
    return Data_Maybe.fromJust()(Data_Set.findMax(v));
};

// | Applies a function to each value in a set, discarding entries where the
// | function returns `Nothing`.
var mapMaybe = function (dictOrd) {
    return function (f) {
        return function (v) {
            return Data_Set.mapMaybe(dictOrd)(f)(v);
        };
    };
};

// | Maps over the values in a set.
// |
// | This operation is not structure-preserving for sets, so is not a valid
// | `Functor`. An example case: mapping `const x` over a set with `n > 0`
// | elements will result in a set with one element.
var map = function (dictOrd) {
    return function (f) {
        return function (v) {
            return Data_Set.map(dictOrd)(f)(v);
        };
    };
};

// | Insert a value into a set.
var insert = function (dictOrd) {
    return function (a) {
        return function (v) {
            return Data_Set.insert(dictOrd)(a)(v);
        };
    };
};

// | Attempts to create a non-empty set from a possibly-empty set.
var fromSet = function (s) {
    var $77 = Data_Set.isEmpty(s);
    if ($77) {
        return Data_Maybe.Nothing.value;
    };
    return new Data_Maybe.Just(s);
};

// | The set of elements which are in both the first and second set. `Nothing`
// | if the sets are disjoint.
var intersection = function (dictOrd) {
    return function (v) {
        return function (v1) {
            return fromSet(Data_Set.intersection(dictOrd)(v)(v1));
        };
    };
};

// | Create a set from a non-empty foldable structure.
var fromFoldable1 = function (dictFoldable1) {
    return function (dictOrd) {
        return Data_Semigroup_Foldable.foldMap1(dictFoldable1)(semigroupNonEmptySet(dictOrd))(singleton);
    };
};

// | Create a set from a foldable structure.
var fromFoldable = function (dictFoldable) {
    return function (dictOrd) {
        return function ($86) {
            return fromSet(Data_Set.fromFoldable(dictFoldable)(dictOrd)($86));
        };
    };
};
var foldableNonEmptySet = Data_Set.foldableSet;
var foldable1NonEmptySet = new Data_Semigroup_Foldable.Foldable1(function () {
    return foldableNonEmptySet;
}, function (dictSemigroup) {
    return Data_Semigroup_Foldable.foldMap1(foldable1NonEmptySet)(dictSemigroup)(Control_Category.identity(Control_Category.categoryFn));
}, function (dictSemigroup) {
    return function (f) {
        return function ($87) {
            return Data_Semigroup_Foldable.foldMap1(Data_List_Types.foldable1NonEmptyList)(dictSemigroup)(f)(toUnfoldable1(Data_List_Types.unfoldable1NonEmptyList)($87));
        };
    };
});

// | Filter out those values of a set for which a predicate on the value fails
// | to hold.
var filter = function (dictOrd) {
    return function (f) {
        return function (v) {
            return Data_Set.filter(dictOrd)(f)(v);
        };
    };
};
var eqNonEmptySet = function (dictEq) {
    return Data_Set.eqSet(dictEq);
};
var eq1NonEmptySet = Data_Set.eq1Set;

// | Form the set difference. `Nothing` if the first is a subset of the second.
var difference = function (dictOrd) {
    return function (v) {
        return function (v1) {
            return fromSet(Data_Set.difference(dictOrd)(v)(v1));
        };
    };
};

// | Delete a value from a non-empty set. If this would empty the set, the
// | result is `Nothing`.
var $$delete = function (dictOrd) {
    return function (a) {
        return function (v) {
            return fromSet(Data_Set["delete"](dictOrd)(a)(v));
        };
    };
};

// | Creates a `NonEmptySet` from an item and a `Set`.
var cons = function (dictOrd) {
    return function (a) {
        return function ($88) {
            return NonEmptySet(Data_Set.insert(dictOrd)(a)($88));
        };
    };
};
module.exports = {
    singleton: singleton,
    cons: cons,
    fromSet: fromSet,
    fromFoldable: fromFoldable,
    fromFoldable1: fromFoldable1,
    toSet: toSet,
    toUnfoldable: toUnfoldable,
    toUnfoldable1: toUnfoldable1,
    map: map,
    member: member,
    insert: insert,
    "delete": $$delete,
    size: size,
    min: min,
    max: max,
    unionSet: unionSet,
    difference: difference,
    subset: subset,
    properSubset: properSubset,
    intersection: intersection,
    filter: filter,
    mapMaybe: mapMaybe,
    eqNonEmptySet: eqNonEmptySet,
    eq1NonEmptySet: eq1NonEmptySet,
    ordNonEmptySet: ordNonEmptySet,
    ord1NonEmptySet: ord1NonEmptySet,
    semigroupNonEmptySet: semigroupNonEmptySet,
    foldableNonEmptySet: foldableNonEmptySet,
    foldable1NonEmptySet: foldable1NonEmptySet,
    showNonEmptySet: showNonEmptySet
};
