"use strict";
var Data_Eq = require("../Data.Eq/index.js");
var Data_EuclideanRing = require("../Data.EuclideanRing/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Int = require("../Data.Int/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ring = require("../Data.Ring/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");
var Data_Show = require("../Data.Show/index.js");
var Effect = require("../Effect/index.js");
var Effect_Random = require("../Effect.Random/index.js");
var $$Math = require("../Math/index.js");
var Partial_Unsafe = require("../Partial.Unsafe/index.js");
var Prelude = require("../Prelude/index.js");

// | A seed for the linear congruential generator. We omit a `Semiring`
// | instance because there is no `zero` value, as 0 is not an acceptable
// | seed for the generator.
var Seed = function (x) {
    return x;
};
var unSeed = function (v) {
    return v;
};
var showSeed = new Data_Show.Show(function (v) {
    return "Seed " + Data_Show.show(Data_Show.showInt)(v);
});

// | The minimum permissible Seed value.
var seedMin = 1;

// | The *modulus*: a magic constant for the linear congruential generator.
// | It is equal to 2^31 - 1, a Mersenne prime. It is useful for this value to
// | be prime, because then the requirement of the initial seed being coprime
// | to the modulus is satisfied when the seed is between 1 and lcgM - 1.
var lcgM = 2147483647;

// | The maximum permissible Seed value.
var seedMax = lcgM - 1 | 0;
var mkSeed = function (x) {
    var ensureBetween = function (min) {
        return function (max) {
            return function (n) {
                var rangeSize = max - min | 0;
                var n$prime = Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(n)(rangeSize);
                var $14 = n$prime < min;
                if ($14) {
                    return n$prime + max | 0;
                };
                return n$prime;
            };
        };
    };
    return ensureBetween(seedMin)(seedMax)(x);
};

// | Create a random seed
var randomSeed = Data_Functor.map(Effect.functorEffect)(mkSeed)(Effect_Random.randomInt(seedMin)(seedMax));

// | The *increment*: a magic constant for the linear congruential generator
var lcgC = 0;

// | The *multiplier*: a magic constant for the linear congruential generator
var lcgA = 48271;

// | Perturb a seed value
var lcgPerturb = function (d) {
    return function (v) {
        return Seed(Data_Maybe.fromJust()(Data_Int.fromNumber($$Math.remainder(Data_Int.toNumber(lcgA) * Data_Int.toNumber(v) + d)(Data_Int.toNumber(lcgM)))));
    };
};

// | Step the linear congruential generator
var lcgNext = lcgPerturb(Data_Int.toNumber(lcgC));
var eqSeed = new Data_Eq.Eq(function (x) {
    return function (y) {
        return x === y;
    };
});
var ordSeed = new Data_Ord.Ord(function () {
    return eqSeed;
}, function (x) {
    return function (y) {
        return Data_Ord.compare(Data_Ord.ordInt)(x)(y);
    };
});
module.exports = {
    mkSeed: mkSeed,
    unSeed: unSeed,
    randomSeed: randomSeed,
    lcgA: lcgA,
    lcgC: lcgC,
    lcgM: lcgM,
    lcgNext: lcgNext,
    lcgPerturb: lcgPerturb,
    eqSeed: eqSeed,
    ordSeed: ordSeed,
    showSeed: showSeed
};
